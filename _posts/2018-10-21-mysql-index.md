---
layout: post
title: Mysql技术：索引与锁
categories:
  - Mysql
tags:
  - Mysql
---

## Innodb索引
Innodb种的索引是使用B+树进行存储的，因此我们首先来了解一下B+树的数据结构

### B+树

一般索引的数据结构是B+树，B+树的数据存储结构如下图所示

![B+树](https://s1.ax1x.com/2018/10/21/iBcc0x.png)

如图中所示，B+树种所有的数据都是按顺序存储的，并且其中的每一块数据都是存放在Innodb的页数据中的（Innodb一页数据是16k大小），这样联讯存放的数据能提高机械硬盘读取数据的效率。由于每个节点能够存放大量的数据，因此Innodb索引生成的B+树的高度一般不会很高（不超过4层）。

为了保持树的平衡，B+树在插入、删除数据的时候可能会进行叶子节点数据的拆分与合并操作，同时如果非叶子节点的数据存储不下的话会分裂出新的非叶子节点，此时B+树的高度会增加。具体细节这里不做过多描述。

### InnoDB索引结构

#### 聚集索引
Innodb的每张表都是按照聚集索引的方式存储的，就是按照每张表的主键构造一颗B+树，同时叶子节点中存放整张表中的行记录数据（如果没有显示声明主键，则会自动生成隐式的主键）。构造一张测试表，并且插入4条数据。其中b字段的长度为7000，这样可以人为的让Innodb每一页的只能存放两条数据（一页数据能保存16k数据）。
```
CREATE TABLE t (
    a INT NOT NULL,
    b VARCHAR(8000),
    c INT NOT NULL,
    PRIMARY KEY (a),
    KEY idx_c (c)
) ENGINE=INNODB;

INSERT INTO t SELECT 1, REPEAT('a', 7000), -1;
INSERT INTO t SELECT 2, REPEAT('a', 7000), -2;
INSERT INTO t SELECT 3, REPEAT('a', 7000), -3;
INSERT INTO t SELECT 4, REPEAT('a', 7000), -4;
```

则数据的存储结构如下图所示，并且因为通过主键能够直接找到存储行数据的地址，因此通过主键进行数据查找的效率是最高的，因此一定要合理利用主键

![Innodb数据存储结构](https://s1.ax1x.com/2018/10/21/iBL6Rs.png)

#### 辅助索引
辅助索引也叫做非聚集索引，每一个辅助索引都是一颗单独的树，无论索引中包括表中多少个字段。辅助索引的构造与聚集索引类似，只是叶子节点中存储的数据是主键索引的值。可以把辅助索引看作是以辅助索引为主键，主键值为行数据的一张表。如果索引只包含一列则索引为该列，如果索引是复合索引，则会将复合索引使用到的列，按照引用的顺序组成一个值进行索引。例如复合索引有a、b、c三列，则在辅助索引中的存放形式可以表示为(a, b, c)。索引的排序则是先a，a相等的情况下找b排序，最后是c。

通过辅助索引查找数据时，则首先通过辅助索引找到相应的数据行的主键，再根据主键找到相应的数据行。也就是说，假设某张表的B+树(辅助索引和主键索引都是)高度是3，则通过主键索引查找一条数据需要查找3次数据页。而通过辅助索引查找一行数据，首先需要通过辅助索引查找3次数据页获得主键ID，然后再在主键索引上查找3次数据页最终得到行数据，即一共需要查找6次数据页。

辅助索引的存储结构如下图所示：
![Innodb辅助索引存储结构](https://s1.ax1x.com/2018/10/28/igZUTx.png)

### InnoDB索引的一些特性

举例用的表结构：
```
CREATE TABLE buy_log (
    id INT NOT NULL AUTO_INCREMENT,
    userid INT NOT NULL,
    date DATE,
    ts INT NOT NULL,
    PRIMARY KEY (id),
    KEY idx_user_date (userid, date)
) ENGINE=INNODB;

INSERT INTO buy_log (userid, date, ts) VALUES (1, '2018-10-01', 1), (1, '2018-11-11', 2), (2, '2018-10-02', 3), (3, '2018-11-10', 4);
```

1. 因为辅助索引是排好序的，因此对于一些有排序操作的sql，如果索引覆盖了的话，可以不用进行额外的排序操作，如果执行sql：`EXPLAIN SELECT * FROM buy_log WHERE userid = 1 ORDER BY date ASC` 可以发现执行计划中不包含`Using filesort`，因为`date`字段在索引中已经排好序了，因此可以直接给出排序结果

2. 当`SELECT`中选择的字段完全囊括在辅助索引中时，则查询可以直接从辅助索引中给出结果，而不再需要去查询聚簇索引。因为辅助索引的数据量要小得多，每一页能够存储更多的数据，因此能够减少IO操作频次，提高查询效率。另外对于某些统计查询，例如上边提到的表执行`SELECT COUNT(*) FROM buy_log`，则查询优化器会选择非聚集索引而非聚集索引，通过执行计划查看的话，可以发现，虽然`possible_keys`为NULL，但是实际会使用`idx_user_date`。类似的，执行`SELECT COUNT(*) FROM buy_log WHERE date > '2018-10-01'`时正常情况下是不会使用索引的，但实际情况依旧会使用`idx_user_date`。

## Innodb锁

### Innodb锁类型

Innodb上的锁类型应该包括表级锁、页级锁、行级锁。加锁的顺序是从粗粒度的锁到细粒度的锁，如果期间有任何部分需要等待，则需要等待粗粒度的锁完成。例如，需要对一行数据row加X锁，则需要先对其所在的表、页加上IX锁，最后对row加上X锁，如果在此之前已经有事务对表加了S锁，则当前事务需要等待表上的S锁释放，在获取到表的IX锁后才能进行下一步操作

```
注意：这些锁当中页锁的资料比较少，也有的说法是当获取不到页锁而且需要获取行锁时，可以跳过页锁，直接等待行锁。待获取到行锁之后再加页锁（参考：http://hedengcheng.com/?p=844）。这种说法的真实性有待验证，因为这样的操作是可能导致死锁的。
```

1. 表锁和页锁：
    - 共享锁（S Lock）
    - 排他锁（X Lock）
    - 意向共享锁（IS Lock）
    - 意向排他锁（IX Lock）

2. 行锁：
    - 共享锁（S Lock），允许对行数据进行读操作
    - 排他锁（X Lock），允许对行数据进行写操作

常用的查看锁状态的命令
1. SHOW ENGINE INNODB STATUS: 可以查看当前锁请求信息以及最后一次死锁的记录
2. 查看SCHEMA下的三张表：INNODB_TRX, INNODB_LOCKS, INNODB_LOCKS_WAITS


### 行锁的3中算法
1. 记录锁：锁定一行记录
2. 间隙锁：用于锁定一个范围，但是不包括记录本身
3. Next-Key：记录锁 + 间隙锁，锁定一个范围，同时锁定记录本身。值得注意的是，Next-Key加锁的过程不是一个原子操作，加锁期间可能会造成死锁

### 行锁加锁的行为模式

*注意：以下仅讨论 RR（repeatable-read）级别下的情况*

举例说明时依旧以`buy_log`为例进行说明

#### 条件为主键：
`DELETE FROM buy_log WHERE id = 3`
这种情况是最简单的情况，因为主键索引是唯一的，当选择`id = 3`的主键索引进行删除的时候回对`id = 3`的记录加上记录锁。同时因为删除数据也涉及到对`userid，date`列的更改，并且这两列数据共同组成了联合索引，因此需要对`(2, '2018-10-02')`这个联合索引的记录也加记录锁。这里加锁是有先后顺序的，首先加主键上的锁，然后再加联合索引上的锁。

![加锁示例-主键](https://s1.ax1x.com/2018/10/25/is4YX8.png)

#### 条件为唯一索引：
条件为唯一索引时，情况与主键类似，所有使用到的锁均为记录锁。不同之处仅在于加锁的顺序不同，即首先会在唯一索引检索到的所有记录上加锁，然后对记录对应的主键上加锁。

#### 条件为普通索引：
这种条件下，加锁的情况比较复杂，除了普通加记录锁之外还要在记录之间加上间隙锁。以`userid`为例，如果执行语句`DELETE FROM buy_log WHERE userid = 2`时没有间隙锁的保护，则执行了这条语句后预期的结果应该是所有的`userid = 2`的记录都被删除了，但如果此时有另外一个事务在该删除语句执行完之后，提交之前往数据库中插入了一条心的`userid = 2`的记录，那么第一个事务提交以后会发现还有`userid = 2`的记录没有被删除，这样的情况明显是不合理的。因此在执行更新操作时，在RR级别下，除了要对存在的记录加锁之外，还要对记录之间的间隙加锁。这也是MYSQL中**RR**和**RC**的区别。

综上所述，执行SQL`DELETE FROM buy_log WHERE userid = 2`时的加锁情况如下图所示，包括主键上的一个记录锁、辅助索引上的一个记录锁和两个间隙锁
![加锁示例-普通索引](https://s1.ax1x.com/2018/10/28/igirlR.png)

为了验证间隙锁，我们可以试着执行如下SQL语句

|  | SessionA | SessionB |
| --- | --- | --- |
| 1 | delete from buy_log where userid = 2 |  |
| 2 | | insert into buy_log set userid = 2, date = '2018-10-12', ts = 5 |

其中第二条语句时会被阻塞的

#### 条件上没有索引
这种情况因为没有索引的辅助，因此只能全表扫描。同时，为了避免幻读，会对表上所有记录，以及记录间所有间隙都加上锁。因为该表上所有的行与间隙都被加上了锁，除了快照读意外，不能更新、不能删除、不能插入，相当于全表锁死。因此在正式环境中的操作一定要极力避免这种情况。

|  | SessionA | SessionB |
| --- | --- | --- |
| 1 | delete from buy_log where ts = 3 |  |
| 2 | | insert into buy_log set userid = 2, date = '2018-10-12', ts = 5 |

其中第二条语句被阻塞

## 死锁
### 产生死锁的四个条件：
1. 互斥：某个资源某一时间只能由一个事务使用
2. 请求和保持：事务工作过程中需要持有一个以上的资源，在其已经持有至少一个资源的情况下再去请求别的资源，同时不释放已经持有的资源
3. 不可剥夺：获得的资源智能由自身释放
4. 循环等待：事务和资源之间相互等待

举例：

|  | SessionA | SessionB |
| --- | --- | --- |
| 1 | select * from buy_log where id = 4 for update; |  |
| 2 | | select * from buy_log where userid >= 3 for update; |
| 2.1 | | select * from buy_log force index(idx_user_date) where userid >= 3 for update; |
| 3 | select * from buy_log where userid = 3 for update; | |

备注：SQL语句**2.1**不需要执行，正常情况下使用语句**2**就行，但是针对数量比较少的表的时候，语句**2**可能会放弃使用联合索引而改用全表扫描，此时加锁的顺序产生变化，会首先给主键索引加锁（这里可以通过EXPLAIN查看），此时语句**2**会阻塞在主键上，而不会对辅助索引加锁，此时执行语句**3**并不会造成死锁。改用语句**2.1**，强制使用辅助索引，此时语句**2**会因为在辅助索引上形成相互等待而造成死锁。

### 面对死锁的一些预防策略
1. 尽可能的使用相同的条件、顺序访问数据: <br>
例如：某张表上有A、B两列唯一索引，那么访问资源的时候尽量仅使用其中的一列，否则容易产生死锁：

2. 在同一次事务中，尽可能一次性取到事务所需要的最大权限: <br>
例如：需要更新`id=1`的一列，那么进行事务的时候尽量使用`select * from t where id = 1 for update`

3. 合理的为表设置索引: <br>
根据以上说明，很容易知道，索引数量越多，越有可能造成死锁。一次，我们在实际业务中必须要合理有效地管理索引

4. 尽量减少事务的使用的资源，减少大事务的使用: <br>
一个事务中使用的资源越多，造成死锁的概率就越高，因此，在业务允许的前提下，我们应该尽可能地减少事务的使用，缩小事务的规模。

> 参考资料: <br>
>1. 《Mysql技术内幕 Innodb存储引擎》<br>
>2.  http://hedengcheng.com/?p=771