---
layout: post
title: Snowflake分布式唯一订单号生成算法
categories:
  - 生产环境
tags:
  - Snowflake
---

Snowflake算法的全称是Twitter-Snowflake，是为了解决在分布式的系统中能够产生唯一ID的算法。算法的核心就是把**时间戳**，**工作机器ID**，**唯一序列号**

除了最高位bit标记为不可用以外，其余三组bit占位均可浮动，看具体的业务需求而定。默认情况下41bit的时间戳可以支持该算法使用到2082年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。

![算法位使用](http://121.40.136.3/wp-content/uploads/2015/04/snowflake-64bit.jpg)

### 时间戳
时间戳使用精确到毫秒级的时间戳，默认情况下使用41bit

### 机器工作ID
这个方法不唯一，可以使用MAC地址、IP地址（如果10bit长度不够用可以仅截取部分，但是要注意可能呢会出现的重复问题，最保险的方法就是自己定义一个机器ID映射表，不过自定义的方法在机器数量很多的情况下要维护这个列表还是非常麻烦的一件事情）等等来标记唯一的机器。

实际上这个ID甚至是可以精确到进程级别的，例如使用 NGINX + PHP-FPM 架构，同一个时刻的ID是可以相同的，但是如果通过不同的进程ID来标记则不会有这样的问题。

### 唯一序列号
这个唯一ID的生成需要注意一个问题，以12bit的唯一ID为例，每个毫秒内每一台机器能够产生4096个ID，在该毫秒结束后可以重置（如果有多线程，注意一定要使用原子操作）。分配ID时需要进行检查，如果在一个毫秒内把自增ID都用掉了，则需要等待到下一个毫秒，将12bit的唯一ID重置，再进行ID的产生。

## 总结
该算法是一个分布式的ID生成算法，虽然不能保证生成ID的序列性，但是能够在各生产节点之间不产生通信的前提下以极高的效率产生出唯一的ID，算法本身只支持64bit的ID产生，实际的生产环境中可以扩展至更多的bit

> 参考资料：https://github.com/twitter/snowflake